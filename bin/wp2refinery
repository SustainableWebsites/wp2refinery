#!/usr/bin/env ruby
require 'hpricot'
require 'trollop'
require 'mysql2'
require 'cgi'
require 'time'

opts = Trollop::options do
  opt :file, "File to import", :required => true, :type => String
  opt :database, "MySQL database", :type => String
  opt :username, "MySQL database user", :type => String
  opt :password, "MySQL database password", :type => String
end

if opts[:database] && opts[:username]
  db = Mysql2::Client.new(:host => "localhost", :database => "#{opts[:database]}", :username => "#{opts[:username]}", :password => "#{opts[:password]}")
end

post = {}
categories = []
users = []

# Parse XML
xml = Hpricot.XML(File.read(opts[:file]))

# Categories 
xml.search('//wp:category').each do |category|
  categories << category.search('wp:cat_name').inner_text

  # Save categories
  if db
   db.query("INSERT INTO blog_categories (title, created_at, updated_at) VALUES ('#{categories.last}', '#{Time.now}', '#{Time.now}')")
  end
end

# Users
xml.search('//dc:creator').each do |user|
  unless users.include?(user.inner_text)
    users << user.inner_text

    # Save users
    if db
      db.query("INSERT INTO users (username, created_at, updated_at) VALUES ('#{users.last}', '#{Time.now}', '#{Time.now}')")
    end
  end
end

# Post
xml.search("//item").each do |item|
  if item.search('wp:post_type').inner_html == "post"
    post[:post_id] = item.search("post_id").inner_html
    post[:title] = item.search("title").inner_html
    post[:link] = item.search("link").inner_html
    post[:published_at] = Time.parse(item.search("pubDate").inner_html)
    post[:creator] = CGI.escapeHTML(item.search("dc:creator").inner_text).gsub(/'/, "\\\\'")
    post[:content] = CGI.escapeHTML(item.search("content:encoded").inner_text).gsub(/'/, "\\\\'")
    post[:excerpt] = CGI.escapeHTML(item.search("excerpt:encoded").inner_text).gsub(/'/, "\\\\'")
    
    post[:wp_post_id] = item.search("wp:comment_status").inner_html
    post[:wp_ping_status] = item.search("wp:ping_status").inner_html
    post[:wp_post_name] = item.search("wp:post_name").inner_html
    post[:wp_status] = item.search("wp:status").inner_html
    post[:wp_post_parent] = item.search("wp:post_parent").inner_html
    post[:wp_menu_order] = item.search("wp:menu_order").inner_html
    post[:wp_post_type] = item.search("wp:post_type").inner_html
    post[:wp_is_sticky] = item.search("wp:is_sticky").inner_html
    
    # Meta
    item.search("wp:postmeta").each_with_index do |meta, index|
      post[:meta] ||= {}
      post[:meta][meta.search("wp:meta_key").inner_html] = meta.search("wp:meta_value").inner_html
    end
    
    # Categories
    item.search("category").each_with_index do |category, index|
      if (index%2 == 0) 
        post[:categories] ||= {}
        post[:categories] = category.inner_text
      end
    end
    
    # Comments
    post[:comments] = nil
    item.search('wp:comment').each_with_index do |comment, index|
      unless comment.search('wp:comment_approved').inner_html == "spam"
        post[:comments] ||= {}
        post[:comments][index] ||= {}
        post[:comments][index][:id] = comment.search('wp:comment_id').inner_html
        post[:comments][index][:author] = CGI.escapeHTML(comment.search('wp:comment_author').inner_text).gsub(/'/, "\\\\'")
        post[:comments][index][:author_email] = comment.search('wp:comment_author_email').inner_html
        post[:comments][index][:author_url] = comment.search('wp:comment_author_url').inner_html
        post[:comments][index][:author_IP] = comment.search('wp:comment_author_IP').inner_html
        post[:comments][index][:comment_date] = Time.parse(comment.search('wp:comment_date').inner_html)
        post[:comments][index][:content] = CGI.escapeHTML(comment.search('wp:comment_content').inner_text).gsub(/'/, "\\\\'")
        post[:comments][index][:approved] = comment.search('wp:comment_approved').inner_html
        post[:comments][index][:type] = comment.search('wp:comment_type').inner_html
        post[:comments][index][:parent] = comment.search('wp:comment_parent').inner_html
        post[:comments][index][:user_id] = comment.search('wp:comment_user_id').inner_html
      end
    end

  elsif item.search('wp:post_type').inner_html == "attachment"
    # TODO: Attachments
  end
  
  # Hardcore database action
  if db    
    unless post[:wp_status] == "auto-draft"    
      # Get inserted user id
      user_id = db.query("SELECT id FROM users WHERE username = '#{post[:creator]}'")
    
      # Convert draft status
      draft = 0
      if post[:wp_status] == "draft"
        draft == 1
      end
      
      # Insert post
      db.query("INSERT INTO blog_posts (title, body, draft, published_at, created_at, updated_at, user_id) VALUES ('#{post[:title]}', '#{post[:content]}', '#{draft}', '#{post[:published_at]}', '#{post[:published_at]}', '#{Time.now}', '#{user_id.first["id"]}')")
      post_id = db.last_id
      
      # Insert Comments
      unless post[:comments] == nil
        post[:comments].each do |comment|
          comment = comment.last
          if comment[:approved] == "1"
            comment[:approved] = "approved"
          else
            # TODO: What are unapproved comments in refinery?
            comment[:approved] = "pending"
          end
        
          db.query("INSERT INTO blog_comments (blog_post_id, spam, name, email, body, state, created_at, updated_at) VALUES ('#{post_id}', '0' '#{comment[:author]}', '#{comment[:author_email]}', '#{comment[:content]}', '#{comment[:approved]}', '#{comment[:comment_date]}', '#{Time.now}')")
        end
      end
      
    end
  end
end
