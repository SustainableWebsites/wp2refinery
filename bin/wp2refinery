#!/usr/bin/env ruby
require 'hpricot'
require 'trollop'
require 'mysql2'
require 'sqlite3'
require 'cgi'
require 'time'
require 'yaml'
require 'active_record'


opts = Trollop::options do
  opt :file, "File to import", :required => true, :type => String
  opt :tags, "File with tags. Existing categories with the same name will be converted", :type => String
  opt :dryrun, "Dry run. Don't import into database"
end


# Read the database.yml file
unless opts[:dryrun]
  db = File.exists?('config/database.yml') ? YAML::load_file('config/database.yml') : nil
  ar = ActiveRecord::Base.establish_connection(db["development"]) if db
end

post = {}
categories = []
users = []

# Parse XML
xml = Hpricot.XML(File.read(opts[:file]))

# Tags
tags = []
unless opts[:tags].nil?
  file_tags = File.new(opts[:tags], 'r')
  file_tags.each do |tag|
    tags << (tag = tag.strip.capitalize)
  
    # if db
    #   db.query("INSERT IGNORE INTO tags (name) VALUES ('#{tag}')")
    # end
  end
end

# Categories 
xml.search('//wp:category').each do |category|
  category = CGI.unescapeHTML(category.search('wp:cat_name').inner_text).gsub(/'/, "\\\\'")
  unless tags.include?(category.capitalize) || categories.include?(category)
    categories << category
  end
  
  # Save categories
  if db && category
    blog_category = BlogCategory.create(:title => category)
  end
end

# Users
xml.search('//dc:creator').each do |user|
  unless users.include?(user.inner_text)
    users << user.inner_text

    # Save users
    if db
      user = User.create(:username => users.last)
    end
  end
end

# Post
xml.search("//item").each do |item|
  post = {}
  if item.search('wp:post_type').inner_html == "post"
    post[:post_id] = item.search("post_id").inner_html
    post[:title] = CGI.unescapeHTML(item.search("title").inner_html).gsub(/'/, "\\\\'")
    post[:link] = item.search("link").inner_html
    post[:published_at] = Time.parse(item.search("pubDate").inner_html)
    post[:created_at] = Time.parse(item.search("wp:post_date").inner_html)
    post[:post_date_gmt] = item.search("wp:post_date_gmt").inner_html
    post[:creator] = item.search("dc:creator").inner_text.gsub(/'/, "\\\\'")
    post[:content] = item.search("content:encoded").inner_text.gsub(/'/, "\\\\'")
    post[:excerpt] = item.search("excerpt:encoded").inner_text.gsub(/'/, "\\\\'")
    
    post[:wp_post_id] = item.search("wp:comment_status").inner_html
    post[:wp_ping_status] = item.search("wp:ping_status").inner_html
    post[:wp_post_name] = item.search("wp:post_name").inner_html
    post[:wp_status] = item.search("wp:status").inner_html
    post[:wp_post_parent] = item.search("wp:post_parent").inner_html
    post[:wp_menu_order] = item.search("wp:menu_order").inner_html
    post[:wp_post_type] = item.search("wp:post_type").inner_html
    post[:wp_is_sticky] = item.search("wp:is_sticky").inner_html
    
    # Meta
    item.search("wp:postmeta").each_with_index do |meta, index|
      post[:meta] ||= {}
      post[:meta][meta.search("wp:meta_key").inner_html] = meta.search("wp:meta_value").inner_html
    end
    
    # Categories
    post[:categories] = nil
    post[:categories] ||= []
    item.search("category").each_with_index do |category, index|
      unless post[:categories].include?(category.inner_text)
        post[:categories] << CGI.unescapeHTML(category.inner_text).gsub(/'/, "\\\\'")
      end
    end
    
    # Comments
    post[:comments] = nil
    item.search('wp:comment').each_with_index do |comment, index|
      unless comment.search('wp:comment_approved').inner_html == "spam"
        post[:comments] ||= {}
        post[:comments][index] ||= {}
        post[:comments][index][:id] = comment.search('wp:comment_id').inner_html
        post[:comments][index][:author] = CGI.escapeHTML(comment.search('wp:comment_author').inner_text).gsub(/'/, "\\\\'")
        post[:comments][index][:author_email] = comment.search('wp:comment_author_email').inner_html
        post[:comments][index][:author_url] = comment.search('wp:comment_author_url').inner_html
        post[:comments][index][:author_IP] = comment.search('wp:comment_author_IP').inner_html
        post[:comments][index][:comment_date] = Time.parse(comment.search('wp:comment_date').inner_html)
        post[:comments][index][:content] = CGI.unescapeHTML(comment.search('wp:comment_content').inner_text).gsub(/'/, "\\\\'")
        post[:comments][index][:approved] = comment.search('wp:comment_approved').inner_html
        post[:comments][index][:type] = comment.search('wp:comment_type').inner_html
        post[:comments][index][:parent] = comment.search('wp:comment_parent').inner_html
        post[:comments][index][:user_id] = comment.search('wp:comment_user_id').inner_html
      end
    end
    
    # Convert to paragraphs
    post[:content] = "<p>#{post[:content]}</p>"
    post[:content].gsub!(/(\r\n\r\n)/, "</p><p>")
    
    # Strip inline styles
    content = Hpricot(post[:content])
    content.search("[@style]").each do |e| 
      unless e.empty?
        e.remove_attribute("style")
      end
    end
    post[:content] = content.inner_html
    
    # Hardcore database action
    if db    
      unless post[:wp_status] == "auto-draft"    
        # Get inserted user id
        author = User.find(post[:creator])

        # Convert draft status
        draft = 0
        draft = 1 if post[:wp_status] == "draft"
        
        if post[:post_date_gmt] == "0000-00-00 00:00:00"
          post[:published_at] = post[:created_at]
        end
        
        # See if we have embeded video
        post[:content].match(/v=([\w]+)/i) {|m| post[:content] = %{<iframe title="YouTube video player" width="480" height="390" src="http://www.youtube.com/embed/#{m}" frameborder="0" allowfullscreen></iframe>}}
        
        # Insert post
        post = BlogPost.new(
          :title => post[:title],
          :body => post[:content],
          :draft => draft,
          :published_at => post[:published_at], 
          :created_at => post[:created_at], 
          :user_id => author.id  
        )

        # Insert Comments
        unless post[:comments] == nil
          post[:comments].each do |comment|
            comment = comment.last
            if comment[:approved] == "1"
              comment[:approved] = "approved"
            else
              comment[:approved] = nil
            end
            
            # TODO: Comments
            comment = post.comments.new(
              :blog_post_id => post.id,
              :spam => 0,
              :name => comment[:author],
              :email => comment[:author_email],
              :body => comment[:content], 
              :state => comment[:approved]
            )
          end
        end
        
        p post.title
        
        # Associate categories & tags
        # post[:categories].each do |cat|
        #   blog_category_id = db.query("SELECT id FROM blog_categories WHERE title LIKE '#{cat}'")
        #   blog_category_id = blog_category_id.first["id"] unless blog_category_id.nil?
        #   if blog_category_id.nil? # It's probably a tag
        #     tag_id = db.query("SELECT id FROM tags WHERE name LIKE '#{cat}'")
        #     tag_id = tag_id.first["id"]
        #     unless tag_id.nil?
        #       db.query("INSERT INTO taggings (tag_id, taggable_id, taggable_type, context, created_at) VALUES ('#{tag_id}', '#{post_id}', 'BlogPost', 'tags', '#{Time.now}')")
        #     end
        #   else # It's a category!
        #     db.query("INSERT INTO blog_categories_blog_posts (blog_category_id, blog_post_id) VALUES ('#{blog_category_id}', '#{post_id}')")
        #   end
        # end
        
      end
      
      # TODO: Save everything to generate friendly ids (needs active_record)
      
      p "#{post[:title]}"
    end
  
  elsif item.search('wp:post_type').inner_html == "attachment"
    # TODO: Attachments
  end  
  
end